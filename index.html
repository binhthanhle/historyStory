<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echoes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Apply Inter font globally */
        body { font-family: 'Inter', sans-serif; }

        /* Custom styles for Markdown rendered content within the story output */
        /* These styles enhance readability and visual hierarchy for generated stories */
        .prose h1 { font-size: 1.875rem; font-weight: bold; margin-top: 1.5rem; margin-bottom: 0.75rem; color: #60A5FA; /* Sky-400 equivalent */ }
        .prose h2 { font-size: 1.5rem; font-weight: bold; margin-top: 1.25rem; margin-bottom: 0.6rem; color: #93C5FD; /* Sky-300 equivalent */ }
        .prose h3 { font-size: 1.25rem; font-weight: bold; margin-top: 1rem; margin-bottom: 0.5rem; color: #BFDBFE; /* Sky-200 equivalent */ }
        .prose p { margin-bottom: 1rem; line-height: 1.75; } /* Increased line-height for better readability */
        .prose strong { font-weight: bold; color: #E0F2FE; /* Lighter sky for emphasis */ }
        .prose em { font-style: italic; color: #BEE3F8; /* Even lighter sky for subtle emphasis */ }
        .prose ul { list-style-type: disc; margin-left: 1.5rem; margin-bottom: 1rem; padding-left: 1rem;}
        .prose li { margin-bottom: 0.5rem; }
        
        /* Ensure audio player and image container maintain good spacing and appearance */
        #audioPlayer { margin-top: 1rem; width: 100%; border-radius: 0.5rem; background-color: #334155; }
        #imageContainer img { display: block; }

        /* Styles for the clickable "Explore Further" buttons at the bottom of the story */
        .highlighted-term-button {
            /* Tailwind classes applied directly for consistency */
            @apply bg-sky-700/20 text-sky-300 hover:bg-sky-600/40 px-3 py-1 rounded-full text-sm font-medium transition-colors duration-300 ease-in-out;
            white-space: nowrap; /* Prevent wrapping for single terms */
        }

        /* Main layout container for panels - uses flexbox for responsive side-by-side or stacked layout */
        #main-content-container {
            display: flex;
            flex-direction: column; /* Default to stacking on small screens */
            gap: 2rem;
            width: 100%;
            max-width: 85rem;
            margin: 0 auto;
        }

        /* Panels styling */
        .panel {
            background-color: #1e293b; /* Slate-800 equivalent */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            border: 1px solid #334155; /* Slate-700 equivalent */
        }

        /* Left Panel: Search History (now top on mobile, left on desktop) */
        #searchHistoryPanel {
            flex: 0 0 auto;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }
        #searchHistoryPanel ul {
            list-style: none;
            padding: 0;
        }
        #searchHistoryPanel button {
            text-align: left;
            color: #93C5FD; /* Sky-300 equivalent */
            transition: background-color 0.2s, color 0.2s;
            border-radius: 0.5rem;
        }
        #searchHistoryPanel button:hover {
            background-color: #334155; /* Slate-700 equivalent */
            color: #E2E8F0; /* Slate-200 equivalent */
        }

        /* Right Panel: Main Content Area */
        #right-content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Input field styling */
        input[type="text"] {
            background-color: #334155; /* Slate-700 equivalent */
            border: 1px solid #475569; /* Slate-600 equivalent */
            color: #E2E8F0; /* Slate-200 equivalent */
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
        }
        input[type="text"]:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.5); /* Sky-400 equivalent */
            border-color: #60A5FA; /* Sky-400 equivalent */
        }
        input::placeholder {
            color: #94A3B8; /* Slate-400 equivalent */
        }

        /* Button base styles */
        button {
            font-weight: 600;
            padding: 0.85rem 1.8rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease-in-out;
            transform: scale(1);
            border: none;
        }
        button:hover {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px) scale(1.02);
        }
        button:active {
            transform: translateY(1px) scale(0.98);
        }
        button:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(96, 165, 250, 0.6); /* Sky-400 equivalent */
        }

        /* Specific button colors */
        .btn-primary {
            background-color: #0EA5E9; /* Sky-500 equivalent */
            color: white;
        }
        .btn-primary:hover {
            background-color: #0284C7; /* Sky-600 equivalent */
        }
        .btn-camera {
            background-color: #4F46E5; /* Indigo-600 equivalent */
            color: white;
        }
        .btn-camera:hover {
            background-color: #4338CA; /* Indigo-700 equivalent */
        }
        .btn-capture {
            background-color: #10B981; /* Emerald-500 equivalent */
            color: white;
        }
        .btn-capture:hover {
            background-color: #059669; /* Emerald-600 equivalent */
        }
        .btn-close {
            background-color: #EF4444; /* Red-500 equivalent */
            color: white;
        }
        .btn-close:hover {
            background-color: #DC2626; /* Red-600 equivalent */
        }

        /* Status and Error messages */
        #geocodingStatus, #imageGenStatus, #cameraStatus, #ttsStatus {
            color: #93C5FD; /* Sky-300 equivalent */
            font-weight: 500;
        }
        #errorMessage {
            background-color: rgba(239, 68, 68, 0.3); /* Red-500 with transparency */
            border: 1px solid #DC2626; /* Red-600 equivalent */
            color: #FCA5A5; /* Red-300 equivalent */
            padding: 1rem;
            border-radius: 0.5rem;
        }

        /* Modal Styles */
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.7);
        }

        .modal-content {
            background-color: #1e293b; /* Slate-800 equivalent */
            color: #E2E8F0; /* Slate-200 equivalent */
            border: 1px solid #334155; /* Slate-700 equivalent */
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .modal-close-btn {
            color: #94A3B8; /* Slate-400 equivalent */
            font-size: 1.8rem;
        }
        .modal-close-btn:hover {
            color: #60A5FA; /* Sky-400 equivalent */
        }

        /* Responsive adjustments for larger screens */
        @media (min-width: 768px) { /* md breakpoint */
            #main-content-container {
                flex-direction: row; /* Side-by-side on larger screens */
                align-items: flex-start; /* Align items to the top */
            }
            #searchHistoryPanel {
                width: 25%; /* History takes quarter width */
                min-width: 200px; /* Ensure it's not too narrow */
            }
            #right-content-area {
                width: 75%; /* Main content takes three-quarters width */
            }
        }
        /* Text selection color */
        ::selection {
            background-color: #60A5FA; /* Sky-400 equivalent */
            color: white;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4 bg-gradient-to-br from-slate-900 to-slate-800 text-slate-100 selection:bg-sky-500 selection:text-white">

    <audio autoplay loop style="display:none;">
      <source src="LandingPageMusic.mp3" type="audio/mp3">
    </audio>

    <div id="main-content-container" class="container mx-auto">
        <main id="right-content-area">
            <header class="text-center mb-8">
                <h1 class="text-4xl font-bold text-sky-400">Echoes</h1>
                <p class="mt-2 text-slate-400">Uncover the whispers of the past. Enter a name, object, or place to hear its historical echoes and glimpse its story.</p>
            </header>

            <form id="postcodeForm" class="space-y-6 mb-8 panel">
                <div>
                    <label for="postcode" class="block text-sm font-medium text-sky-300 mb-1">Artifact (e.g., Old Book, Roman Forum, Shakespeare)</label>
                    <input type="text" name="postcode" id="postcode" required
                            class="w-full px-4 py-3 rounded-lg outline-none transition-all bg-slate-700 border border-slate-600 text-slate-100 focus:ring-2 focus:ring-sky-500 focus:border-sky-500"
                            placeholder="e.g., Old Book, Roman Forum, Shakespeare">
                </div>
                <button type="submit" class="w-full btn-primary">
                Unveil the Past
                </button>
            </form>

            <section class="mt-8 p-6 panel">
                <h2 class="text-2xl font-bold text-sky-400 mb-4 text-center">Capture a Moment</h2>
                <div class="flex justify-center mb-4">
                    <button id="openCameraButton" class="btn-camera px-8 py-4 text-lg">
                        Open Camera
                    </button>
                </div>

                <div id="cameraFeedContainer" class="hidden flex-col items-center">
                    <video id="cameraFeed" class="w-full max-w-md rounded-lg border shadow-md border-slate-600" autoplay></video>
                    <canvas id="cameraCanvas" class="hidden"></canvas>
                    <button id="capturePhotoButton" class="mt-4 btn-capture">
                        Capture Photo
                    </button>
                    <button id="closeCameraButton" class="mt-2 btn-close">
                        Close Camera
                    </button>
                    <p id="cameraStatus" class="mt-2 text-sm text-sky-300 text-center"></p>
                </div>
            </section>

            <div id="loadingIndicator" class="mt-8 text-center hidden">
                <div class="inline-flex items-center">
                    <svg class="animate-spin -ml-1 mr-3 h-6 w-6 text-sky-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span class="text-slate-300">Summoning history...</span>
                </div>
            </div>
            
            <p id="geocodingStatus" class="mt-4 text-sm text-sky-300 text-center hidden"></p>
            <p id="imageGenStatus" class="mt-2 text-sm text-sky-300 text-center hidden"></p>

            <div id="errorMessage" class="mt-6 px-4 py-3 rounded-lg hidden bg-red-700/30 border border-red-600 text-red-300" role="alert">
            </div>
            
            <section id="storyDisplayArea" class="panel flex flex-col space-y-4 mt-8 overflow-y-auto max-h-[80vh]">
                <article id="storyOutput" class="prose max-w-none text-slate-200"></article>
                <div id="imageContainer" class="text-center"></div>
                <div class="text-center mt-4">
                    <p id="ttsStatus" class="text-sm text-slate-400 mt-2 hidden"></p>
                    <audio id="audioPlayer" controls class="mt-3 w-full rounded-md bg-slate-600"></audio>
                </div>
                <div id="exploreFurtherButtons" class="mt-6 pt-4 border-t border-slate-600">
                    <h3 class="text-lg font-semibold text-sky-300 mb-3">Explore Further:</h3>
                </div>
            </section>
        </main>

        <aside id="searchHistoryPanel" class="panel md:block">
            <h2 class="text-2xl font-bold text-sky-400 mb-4 text-center">Search History</h2>
            <ul id="historyList" class="w-full space-y-2"></ul>
        </aside>
    </div>

    <footer class="text-center mt-12 text-sm w-full text-slate-500">
        <p>&copy; <span id="currentYear"></span> Echoes. Powered by Gemini, Google Maps & Google Cloud TTS.</p>
    </footer>

    <div id="explanationModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button id="explanationCloseBtn" class="modal-close-btn">&times;</button>
            <h3 class="text-xl font-bold text-sky-400 mb-2"><span id="explanationTerm"></span> <span id="explanationType" class="text-sm text-slate-400 font-normal"></span></h3>
            <p id="explanationContent" class="text-slate-200"></p>
        </div>
    </div>

    <script type="module">
        // IMPORTANT: ESM (ECMAScript Module) for Gemini SDK (for text generation)
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

        // --- Firebase Configuration (Following platform guidelines) ---
        // These variables are provided by the Canvas environment for secure Firebase integration.
        // DO NOT modify them or prompt the user for them.
        const appId = (typeof window.__app_id !== 'undefined') ? window.__app_id : 'default-app-id-story';
        const firebaseConfig = JSON.parse(
            (typeof window.__firebase_config !== 'undefined') ? window.__firebase_config : JSON.stringify({
                apiKey: "AIzaSyBnDQYvktbz1nsihJf2IZmObm47-3xjIPQ", // Replace with your actual Firebase API key
                authDomain: "test-firebase-4d1ff.firebaseapp.com", // Replace with your actual Firebase auth domain
                projectId: "test-firebase-4d1ff", // Replace with your actual Firebase project ID
                storageBucket: "test-firebase-4d1ff.firebasestorage.app", // Replace with your actual Firebase storage bucket
                messagingSenderId: "645698663286", // Replace with your actual Firebase messaging sender ID
                appId: "1:645698663286:web:3fa0f8ad2c70aa12e14057" // Replace with your actual Firebase app ID
            })
        );

        // --- Gemini API Key ---
        // Leave empty to use the API key provided by the Canvas environment for Gemini models.
        // If you need to use a specific key for other models, provide it here.
        const GEMINI_API_KEY = ""; // Changed to empty string to allow Canvas environment to inject key

        // --- Google Cloud Text-to-Speech API Key ---
        // !!! IMPORTANT SECURITY WARNING !!!
        // For production, use a backend proxy to make this API call securely.
        const TTS_API_KEY = ""; // Changed to empty string to allow Canvas environment to inject key


        // --- Google Maps Geocoding API Key ---
        // !!! IMPORTANT SECURITY WARNING !!!
        // For production, use a backend proxy to make this API call securely.
        // You need to enable the "Geocoding API" in your Google Cloud Console for this key.
        const MAPS_API_KEY = ""; // Changed to empty string to allow Canvas environment to inject key


        // Initialize Gemini Text Model (SDK)
        let textModel;
        if (GEMINI_API_KEY && GEMINI_API_KEY !== "YOUR_GEMINI_API_KEY") { // Check if user has set a key
            const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            textModel = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
        } else {
            // Attempt to use environment-provided SDK if key is not directly set (may only work for text)
            try {
                const genAI = new GoogleGenerativeAI(""); // SDK might pick up env key
                textModel = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
                console.info("Attempting to use environment-provided Gemini SDK for text (or API key is default placeholder).");
            } catch (e) {
                console.error("Failed to initialize Gemini SDK without explicit API key.", e);
                // textModel will remain undefined, handled later
            }
        }


        // DOM Elements
        const postcodeForm = document.getElementById('postcodeForm');
        const postcodeValue = document.getElementById('postcode');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const errorMessage = document.getElementById('errorMessage');
        const geocodingStatus = document.getElementById('geocodingStatus');
        const imageGenStatus = document.getElementById('imageGenStatus');
        
        // Re-added direct references for single story display
        const storyOutput = document.getElementById('storyOutput');
        const imageContainer = document.getElementById('imageContainer');
        const audioPlayer = document.getElementById('audioPlayer'); // This is for TTS audio
        const ttsStatus = document.getElementById('ttsStatus');

        const searchHistoryPanel = document.getElementById('searchHistoryPanel'); // Left panel for search history

        // New DOM elements for the explanation modal
        const explanationModal = document.getElementById('explanationModal');
        const explanationTerm = document.getElementById('explanationTerm');
        const explanationType = document.getElementById('explanationType');
        const explanationContent = document.getElementById('explanationContent');
        const explanationCloseBtn = document.getElementById('explanationCloseBtn');

        // New DOM elements for camera feature
        const openCameraButton = document.getElementById('openCameraButton');
        const cameraFeedContainer = document.getElementById('cameraFeedContainer');
        const cameraFeed = document.getElementById('cameraFeed');
        const cameraCanvas = document.getElementById('cameraCanvas');
        const capturePhotoButton = document.getElementById('capturePhotoButton');
        const closeCameraButton = document.getElementById('closeCameraButton');
        const cameraStatus = document.getElementById('cameraStatus');


        // Global variable to hold the current story text for TTS
        let currentTextStory = "";
        let searchHistory = []; // Array to store search history (max 10 items)
        let currentStream; // To hold the camera stream

        // Function to escape HTML special characters
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        // Function to convert Markdown to plain text for TTS
        function convertMarkdownToPlainText(markdown) {
            let text = markdown;
            // Remove titles (h1, h2, h3)
            text = text.replace(/^#+\s+(.*)/gm, '$1. ');
            // Remove bold and italic formatting
            text = text.replace(/[\*_]{1,2}(.*?)[*_]{1,2}/g, '$1');
            // Remove image and link markdown
            text = text.replace(/!\[(.*?)\]\(.*?\)/g, '$1');
            text = text.replace(/\[(.*?)\]\(.*?\)/g, '$1');
            // Remove list item markers
            text = text.replace(/^\s*[\*\-\+]\s+/gm, '');
            // Replace multiple newlines with a period and space for better flow
            text = text.replace(/\n\s*\n/g, '. ');
            // Replace single newlines with a space
            text = text.replace(/\n/g, ' ');
            // Escape backticks to prevent breaking template literals when used in other template literals
            text = text.replace(/`/g, '\\`');
            // Trim whitespace and reduce multiple spaces to a single space
            text = text.replace(/\s+/g, ' ').trim();
            return text;
        }

        // Function to convert Markdown to HTML for display
        function convertMarkdownToHtml(markdown) {
            let html = markdown;
            // Convert headers
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            // Convert bold and italic
            html = html.replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>');
            html = html.replace(/__(.*?)__/gim, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/gim, '<em>$1</em>');
            html = html.replace(/_(.*?)_/gim, '<em>$1</em>');
            
            // Convert lists
            html = html.replace(/^\s*[\*\-\+]\s+(.*)/gim, (match, item) => `<li>${item}</li>`);
            let inList = false;
            html = html.split('\n').map(line => {
                if (line.startsWith('<li>') && !inList) { inList = true; return '<ul>' + line; }
                if (!line.startsWith('<li>') && inList) { inList = false; return '</ul>' + line; }
                return line;
            }).join('\n');
            if (inList) html += '</ul>';

            // Convert paragraphs, handling line breaks within paragraphs
            html = html.split(/\n\s*\n/).map(paragraph => {
                const trimmed = paragraph.trim();
                if (!trimmed) return '';
                // Don't wrap block-level elements like headers, lists, etc. in <p> tags
                if (trimmed.match(/^<(h[1-6]|ul|ol|li|blockquote|pre|hr)/i)) return trimmed;
                return `<p>${trimmed.replace(/\n/g, '<br>')}</p>`;
            }).join('');
            // Remove empty paragraphs
            html = html.replace(/<p><\/p>/g, '').replace(/<p><br\s*\/?>\s*<\/p>/gi, '');
            return html;
        }

        // Function to display error messages
        function displayError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        // Function to synthesize and play audio (for TTS)
        async function synthesizeAndPlayAudio(text, audioPlayerElement, ttsStatusElement) {
            if (!text) { ttsStatusElement.textContent = "No story available for audio."; ttsStatusElement.classList.remove('hidden'); return; }
            // Check if TTS_API_KEY is available. If not, log a warning and skip.
            if (!TTS_API_KEY || TTS_API_KEY === "") {
                ttsStatusElement.textContent = "TTS API Key not configured. Audio playback skipped.";
                ttsStatusElement.classList.remove('hidden');
                displayError("Audio generation skipped: Google Cloud Text-to-Speech API Key is missing. Please ensure it's configured and the API is enabled in your Google Cloud Console.");
                return;
            }

            const plainTextForTTS = convertMarkdownToPlainText(text);
            ttsStatusElement.textContent = "Generating audio...";
            ttsStatusElement.classList.remove('hidden');
            audioPlayerElement.src = ''; // Clear previous audio

            const ttsUrl = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${TTS_API_KEY}`;
            const requestBody = {
                input: { text: plainTextForTTS.substring(0, 4999) }, // Max 5000 chars for TTS
                voice: { languageCode: 'en-UK', name: 'en-GB-News-K' },
                audioConfig: { 
                    audioEncoding: 'MP3',
                    speakingRate: 0.85 // Slow down the voice (0.5 is half, 1.0 is normal, 2.0 is double)
                }
            };

            try {
                const ttsResponse = await fetch(ttsUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
                if (!ttsResponse.ok) {
                    const err = await ttsResponse.json();
                    throw new Error(`TTS API: ${err.error?.message || ttsResponse.statusText}`);
                }
                const resData = await ttsResponse.json();
                if (resData.audioContent) {
                    audioPlayerElement.src = `data:audio/mp3;base64,${resData.audioContent}`;
                    audioPlayerElement.play();
                    ttsStatusElement.textContent = "Playing audio...";
                } else {
                    throw new Error("No audio content from TTS API.");
                }
            } catch (err) {
                console.error("TTS Error:", err);
                ttsStatusElement.textContent = `TTS Error: ${err.message.substring(0, 100)}`;
                displayError(`Audio generation failed: ${err.message}. Please ensure your TTS API key is valid and the API is enabled in your Google Cloud Console.`);
            }
        }

        /**
         * Calls the Gemini API to extract entities (names, places, objects) from a given text.
         * @param {string} text The story text from which to extract entities.
         * @returns {Promise<string[]>} A promise that resolves to an array of strings, where each string is an entity to highlight.
         */
        async function extractEntitiesForHighlighting(text) {
            if (!textModel) {
                console.warn("Gemini text model not available. Cannot extract entities for highlighting.");
                return [];
            }

            const entityPrompt = `
            Given the following story, identify and list the 5 most significant names of human, objects, places, areas, or objects directly related to the place mentioned in the story.
            Provide the response as a JSON array of strings, where each string is a term to be highlighted.
            Do not include any other text or formatting outside the JSON array.
            Story:
            """
            ${text}
            """
            `;

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: entityPrompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "ARRAY",
                            items: { "type": "STRING" },
                            maxItems: 5 // Limit to 5 items
                        }
                    }
                };

                const apiKey = GEMINI_API_KEY === "YOUR_GEMINI_API_KEY" ? "" : GEMINI_API_KEY; // Use empty string if placeholder
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorDetails = await response.text();
                    throw new Error(`Entity extraction API error: ${response.status} ${response.statusText} - ${errorDetails}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonString = result.candidates[0].content.parts[0].text;
                    try {
                        const entities = JSON.parse(jsonString);
                        if (Array.isArray(entities)) {
                            return entities.slice(0, 5); // Ensure max 5 items
                        } else {
                            console.warn("LLM returned non-array for entities:", entities);
                            return [];
                        }
                    } catch (parseError) {
                        console.error("Failed to parse LLM entity response as JSON:", jsonString, parseError);
                        return [];
                    }
                } else {
                    console.warn("No entity content from LLM:", result);
                    return [];
                }
            } catch (error) {
                console.error("Error during entity extraction:", error);
                displayError(`Failed to extract entities for highlighting: ${error.message}`);
                return [];
            }
        }

        /**
         * Calls the Gemini API to explain a selected text/phrase.
         * @param {string} selectedText The text/phrase selected by the user.
         * @param {string} fullStoryContext The full story text for context.
         * @returns {Promise<{term: string, type: string, explanation: string}|null>} A promise that resolves to an object containing the explanation, or null if an error occurs.
         */
        async function getExplanationForSelectedText(selectedText, fullStoryContext) {
            if (!textModel) {
                console.warn("Gemini text model not available. Cannot get explanation.");
                return null;
            }

            const explanationPrompt = `
            Given the following selected text/phrase from a story, provide a brief explanation or definition.
            Also, identify its type: "place", "area", "human", "object", or "concept".
            Provide the response as a JSON object with keys: "term", "type", and "explanation".
            Ensure the "explanation" is concise and directly relevant to the context of the story.
            Do not include any other text or formatting outside the JSON object.

            Selected Text: "${selectedText}"
            Full Story Context: "${fullStoryContext.substring(0, 1000)}..."
            `;

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: explanationPrompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "term": { "type": "STRING" },
                                "type": { "type": "STRING" },
                                "explanation": { "type": "STRING" }
                            },
                            required: ["term", "type", "explanation"]
                        }
                    }
                };

                const apiKey = GEMINI_API_KEY === "YOUR_GEMINI_API_KEY" ? "" : GEMINI_API_KEY;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorDetails = await response.text();
                    throw new Error(`Explanation API error: ${response.status} ${response.statusText} - ${errorDetails}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonString = result.candidates[0].content.parts[0].text;
                    try {
                        const explanationData = JSON.parse(jsonString);
                        return explanationData;
                    } catch (parseError) {
                        console.error("Failed to parse LLM explanation response as JSON:", jsonString, parseError);
                        return null;
                    }
                } else {
                    console.warn("No explanation content from LLM:", result);
                    return null;
                }
            } catch (error) {
                console.error("Error during explanation generation:", error);
                displayError(`Failed to get explanation: ${error.message}`);
                return null;
            }
        }

        /**
         * Updates the search history panel with the latest search terms.
         * Limits the history to 10 unique items.
         */
        function updateSearchHistoryPanel() {
            // Clear existing list
            searchHistoryPanel.innerHTML = `
                <h2 class="text-2xl font-bold text-sky-400 mb-4 text-center">Search History</h2>
                <ul id="historyList" class="w-full space-y-2"></ul>
            `;
            const historyList = document.getElementById('historyList');

            // Add unique terms to history, limit to 10
            const uniqueHistory = Array.from(new Set(searchHistory)); // Ensure uniqueness
            searchHistory = uniqueHistory.slice(0, 10); // Keep only the latest 10

            searchHistory.forEach(term => {
                const listItem = document.createElement('li');
                const button = document.createElement('button');
                button.textContent = term;
                button.classList.add('w-full', 'text-left', 'px-3', 'py-2', 'rounded-md', 'transition-colors', 'duration-200', 'text-sky-300', 'hover:bg-slate-700');
                button.setAttribute('data-term', term);
                button.addEventListener('click', () => {
                    postcodeValue.value = term; // Set the input field
                    postcodeForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true })); // Trigger form submission
                });
                listItem.appendChild(button);
                historyList.appendChild(listItem);
            });
        }

        /**
         * Analyzes a base64 encoded image to identify a relevant term (object, human, or location) using Gemini Vision API.
         * Returns a structured object with type and name.
         * @param {string} base64ImageData The base64 encoded image data.
         * @returns {Promise<{type: string, name: string}|null>} A promise that resolves to an object with identified type and name, or null.
         */
        async function analyzeImageForLocation(base64ImageData) {
            cameraStatus.textContent = "Analyzing image...";
            loadingIndicator.classList.remove('hidden');

            if (!GEMINI_API_KEY || GEMINI_API_KEY === "" ) { // Removed YOUR_GEMINI_API_KEY check as it's now an empty string by default
                cameraStatus.textContent = "Gemini API Key for image analysis is not configured. Cannot analyze image.";
                displayError("Gemini API Key needed for image analysis. Please ensure it's configured and the API is enabled in your Google Cloud Console.");
                loadingIndicator.classList.add('hidden');
                return null;
            }

            const dataPart = base64ImageData.split(',')[1];
            if (!dataPart) {
                displayError("Invalid image data provided for analysis.");
                loadingIndicator.classList.add('hidden');
                return null;
            }

            const prompt = `
            Analyze this image and identify the most prominent content.
            Classify it into one of these types: "object", "human", "location", "general_item".
            Provide the specific name or description of the identified content.
            If it's an object, try to identify if it's a historical object (e.g., "Statue of Cleopatra", "Ancient Roman Coin").
            If it's a human, identify the person if recognizable (e.g., "Abraham Lincoln", "Queen Elizabeth II").
            If it's a location, identify the specific landmark, building, or area (e.g., "Eiffel Tower", "Roman Forum").
            If it's a general item, provide its name (e.g., "flower", "desk lamp").
            
            Respond only with a JSON object in the format:
            {
                "type": "object" | "human" | "location" | "general_item",
                "name": "Identified name or description"
            }
            Do not include any other text or markdown outside the JSON object.
            `;

            try {
                const payload = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                { text: prompt },
                                {
                                    inlineData: {
                                        mimeType: "image/png",
                                        data: dataPart
                                    }
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: 0.2,
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "type": { "type": "STRING", "enum": ["object", "human", "location", "general_item"] },
                                "name": { "type": "STRING" }
                            },
                            required: ["type", "name"]
                        }
                    }
                };

                const apiKey = GEMINI_API_KEY; // Use the GEMINI_API_KEY directly, which is now empty by default
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorDetails = await response.text();
                    throw new Error(`Image analysis API error: ${response.status} ${response.statusText} - ${errorDetails}`);
                }

                const result = await response.json();
                loadingIndicator.classList.add('hidden');

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const identifiedData = JSON.parse(result.candidates[0].content.parts[0].text);
                    cameraStatus.textContent = `Identified: ${identifiedData.name} (${identifiedData.type})`;
                    return identifiedData;
                } else {
                    cameraStatus.textContent = "Could not identify content from the image.";
                    return null;
                }
            } catch (error) {
                console.error("Error during image analysis:", error);
                displayError(`Failed to analyze image: ${error.message}. Please ensure your Gemini API key is valid and the Generative Language API is enabled in your Google Cloud Console.`);
                loadingIndicator.classList.add('hidden');
                return null;
            }
        }


        // Event listener for form submission (existing logic, now potentially called by camera)
        postcodeForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const inputArtifact = postcodeValue.value.trim(); // This will be the location from text input OR from camera

            // Add current search term to history (if not empty and not already the first item)
            if (inputArtifact && (searchHistory.length === 0 || searchHistory[0] !== inputArtifact)) {
                searchHistory.unshift(inputArtifact); // Add to the beginning
                searchHistory = searchHistory.slice(0, 10); // Keep only the latest 10
                updateSearchHistoryPanel();
            }

            // Input validation and API key checks
            if (!inputArtifact) { displayError("Please enter an artifact."); return; }
            if (!MAPS_API_KEY || MAPS_API_KEY === "" ) { console.warn("Google Maps API Key is not configured. Geocoding will be skipped."); /* Continue without geocoding if key is missing */ }
            if (!textModel && (GEMINI_API_KEY === "" )) { displayError("Gemini API Key for text generation is not configured and SDK couldn't initialize."); return; }

            // Clear global status messages and show loading indicator
            geocodingStatus.textContent = ''; geocodingStatus.classList.add('hidden');
            imageGenStatus.textContent = ''; imageGenStatus.classList.add('hidden');
            errorMessage.classList.add('hidden'); errorMessage.textContent = '';
            loadingIndicator.classList.remove('hidden');

            let determinedArtifactName = inputArtifact;
            let determinedArtifactType = "text_input"; // Default type for manual input

            // Check if the event has custom detail (meaning it came from image analysis)
            if (event.detail && event.detail.identifiedType) {
                determinedArtifactType = event.detail.identifiedType;
            }

            try {
                let payload; // Declared payload here to prevent ReferenceError
                // --- Step 1: Geocode Postcode (if API key is available AND it's likely a location) ---
                let geocodedAddress = null;
                // Only attempt geocoding if the identified type is 'location' or 'general_item' (where location context might be needed)
                // or if it's a generic text input.
                if ((determinedArtifactType === "location" || determinedArtifactType === "general_item" || determinedArtifactType === "text_input") &&
                    MAPS_API_KEY && MAPS_API_KEY !== "") {
                    
                    geocodingStatus.textContent = `Attempting to pinpoint for: ${inputArtifact}...`;
                    geocodingStatus.classList.remove('hidden');
                    const geocodingUrl = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(inputArtifact)}&key=${MAPS_API_KEY}`;
                    const mapsResponse = await fetch(geocodingUrl);
                    const mapsData = await mapsResponse.json();

                    if (mapsData.status === "OK" && mapsData.results && mapsData.results.length > 0) {
                        geocodedAddress = mapsData.results[0].formatted_address;
                        geocodingStatus.textContent = `Information revealed: ${geocodedAddress}`;
                        determinedArtifactName = geocodedAddress; // Use formatted address if successful
                        determinedArtifactType = "location"; // Confirm type as location
                    } else {
                        geocodingStatus.textContent = `Could not pinpoint exact location for "${inputArtifact}". Using original term.`;
                        // determinedArtifactName remains inputArtifact, type remains as initially determined or default
                    }
                } else {
                    geocodingStatus.textContent = `Skipping geocoding for "${inputArtifact}" (type: ${determinedArtifactType} or Maps API key missing).`;
                }

                // --- Step 2: Generate Historical Story (Text) ---
                if (!textModel) {
                    displayError("Gemini text model not available. Cannot weave a story.");
                    loadingIndicator.classList.add('hidden');
                    return;
                }
                if (!geocodingStatus.classList.contains('hidden')) {
                    geocodingStatus.textContent += ` | Weaving a tale...`; 
                } else {
                    geocodingStatus.textContent = `Weaving a tale for: ${determinedArtifactName}...`;
                    geocodingStatus.classList.remove('hidden');
                }
                
                let storyPrompt = `You are a historian and storyteller. A user has provided an artifact, identified as: "${determinedArtifactName}".`;

                // Tailor prompt based on identified type
                switch (determinedArtifactType) {
                    case "object":
                        storyPrompt += `
                        Please provide a detailed historical story specifically about this object. Focus on:
                        - What is this object?
                        - When did it appear or become significant?
                        - Where is its origin or primary association?
                        - Who was involved with its creation, use, or discovery?
                        - Why is it historically important or significant?
                        - How did it come to be, or how did it impact history?
                        Do NOT provide a story about a human or location if the object is clearly the focus.
                        `;
                        break;
                    case "human":
                        storyPrompt += `
                        Please provide a detailed historical story about this human. Focus on:
                        - Who is this human?
                        - When did they live or were they prominent?
                        - Where did they live and carry out their significant actions?
                        - Why are they historically popular or important?
                        - How did their life or actions impact history?
                        `;
                        break;
                    case "location":
                        storyPrompt += `
                        Please provide a detailed historical story about this location. Focus on:
                        - What is this location (e.g., building, city, natural area)?
                        - Where is it located?
                        - When were key historical events associated with it?
                        - Who were the significant figures or groups connected to it?
                        - Why is it historically important or significant?
                        - How did it evolve or how did events there impact history?
                        `;
                        break;
                    case "general_item":
                        storyPrompt += `
                        This appears to be a general item. Please research and provide a historical story about a significant location or cultural context related to this item. Focus on:
                        - What is the item and its general purpose?
                        - Where is it historically significant, commonly found, or symbolically important?
                        - When did this association become prominent?
                        - Who might be associated with its cultural significance or production?
                        - Why is this item or its associated location historically or culturally relevant?
                        - How did this item become connected to its associated location or culture?
                        `;
                        break;
                    case "text_input": // Fallback for direct text input if not geocoded
                    default:
                        storyPrompt += `
                        Please find relevant historical information, notable events, figures, or developments related to "${determinedArtifactName}".
                        Write an interesting and concise historical story about it.
                        `;
                        break;
                }

                storyPrompt += `
                The story must be in Markdown format and include a suitable title.
                Do not include any "Image Suggestion:" line at the end of your response.
                Keep the context as a story on the book, good reading.
                Format the text as the book content, beware to remove all \`\`\`markdown
                If you cannot find specific historical information for "${determinedArtifactName}", try to find information for the broader context (e.g., town/city or region it belongs to), clearly stating this in the story. If no relevant historical information can be reasonably found, respond with a polite message in Markdown, stating that the app cannot process and collect a historical story about it.
                `;

                const storyResult = await textModel.generateContent(storyPrompt);
                const storyResponse = await storyResult.response;
                let fullStoryText = storyResponse.text();

                currentTextStory = fullStoryText.trim(); 

                // --- Step 3: Extract Entities ---
                imageGenStatus.textContent = `Identifying key terms...`;
                const entitiesToHighlight = await extractEntitiesForHighlighting(currentTextStory);
                
                // --- Step 4: Generate Image based on Story ---
                let imageUrl = `https://placehold.co/600x400/E07A5F/FFFFFF?text=${encodeURIComponent("Image generation failed")}&font=lora`; // Default placeholder
                if (GEMINI_API_KEY === "" ) { // Check if GEMINI_API_KEY is empty/default for image generation
                    imageGenStatus.textContent = "Gemini API Key needed for visual echoes. Skipping image generation.";
                    imageGenStatus.classList.remove('hidden');
                    console.warn("GEMINI_API_KEY is empty or default, skipping image generation.");
                    const placeholderMsg = encodeURIComponent("Image generation skipped (API key missing)");
                    imageUrl = `https://placehold.co/600x400/666666/FFFFFF?text=${placeholderMsg}&font=lora`;
                } else {
                    imageGenStatus.textContent = "Conjuring a visual echo...";
                    imageGenStatus.classList.remove('hidden');

                    let imagePromptText = `Generate a historically relevant and visually compelling image that captures the essence of the following story. Focus on key elements or the overall mood. Story: "${convertMarkdownToPlainText(currentTextStory).substring(0, 500)}..."`;

                    const imageApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${GEMINI_API_KEY}`;
                    const imagePayload = {
                        instances: [{ prompt: imagePromptText }],
                        parameters: { "sampleCount": 1 }
                    };

                    const imageGenResponse = await fetch(imageApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(imagePayload)
                    });

                    if (!imageGenResponse.ok) {
                        const errorDetail = await imageGenResponse.text();
                        console.error("Image generation API error response:", errorDetail);
                        displayError(`Image generation failed: ${imageGenResponse.status} ${imageGenResponse.statusText}. Check console for details. Ensure your API key has 'imagen-3.0-generate-002' enabled.`);
                    } else {
                        const imageData = await imageGenResponse.json();
                        if (imageData.predictions && imageData.predictions.length > 0 && imageData.predictions[0].bytesBase64Encoded) {
                            imageUrl = `data:image/png;base64,${imageData.predictions[0].bytesBase64Encoded}`;
                            imageGenStatus.textContent = "Visual echo created.";
                        } else {
                            console.error("No image data received or unexpected format:", imageData);
                            imageGenStatus.textContent = "Failed to create visual echo.";
                        }
                    }
                }

                // --- Step 5: Display Story, Image, TTS Controls, and Explore Further Buttons ---
                const storyHtml = convertMarkdownToHtml(currentTextStory);
                storyOutput.innerHTML = storyHtml; // Update the single storyOutput div
                imageContainer.innerHTML = `<img src="${imageUrl}" alt="AI-generated image for the story" class="mx-auto my-4 rounded-lg shadow-md max-w-full h-auto object-contain" style="max-height: 400px;">`; // Update the single imageContainer div

                // Clear previous explore further buttons and add new ones
                const exploreFurtherDiv = document.getElementById('exploreFurtherButtons');
                exploreFurtherDiv.innerHTML = ''; // Clear existing buttons
                const termsTitle = document.createElement('h3');
                termsTitle.classList.add('text-lg', 'font-semibold', 'text-sky-300', 'mb-3');
                termsTitle.textContent = 'Explore Further:';
                exploreFurtherDiv.appendChild(termsTitle);

                if (entitiesToHighlight.length > 0) {
                    const termsFlexContainer = document.createElement('div');
                    termsFlexContainer.classList.add('flex', 'flex-wrap', 'gap-2');
                    entitiesToHighlight.forEach(term => {
                        const termButton = document.createElement('button');
                        termButton.classList.add('highlighted-term-button');
                        termButton.textContent = term;
                        termButton.setAttribute('data-term', term);
                        termButton.addEventListener('click', () => {
                            postcodeValue.value = term; // Set the input field
                            postcodeForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true })); // Trigger form submission
                        });
                        termsFlexContainer.appendChild(termButton);
                    });
                    exploreFurtherDiv.appendChild(termsFlexContainer);
                } else {
                    const noTerms = document.createElement('p');
                    noTerms.classList.add('text-sm', 'text-slate-400');
                    noTerms.textContent = 'No specific terms identified for further exploration.';
                    exploreFurtherDiv.appendChild(noTerms);
                }

                // --- Step 6: Play TTS Audio for the new story ---
                await synthesizeAndPlayAudio(currentTextStory, audioPlayer, ttsStatus); // Use direct audioPlayer and ttsStatus

                geocodingStatus.textContent = `Information revealed for: ${determinedArtifactName} | Story unveiled.`;

            } catch (error) {
                console.error("Error during processing:", error);
                displayError(`Sorry, an error occurred: ${error.message}. Check console for details.`);
                geocodingStatus.classList.add('hidden');
                imageGenStatus.classList.add('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        });

        // Audio player event listeners for status updates (for TTS audio)
        audioPlayer.onended = () => {
            ttsStatus.textContent = "Audio echo finished.";
        };
        audioPlayer.onerror = () => {
            ttsStatus.textContent = "Error playing audio echo.";
        };
        audioPlayer.onpause = () => {
            if (audioPlayer.currentTime > 0 && !audioPlayer.ended) {
                ttsStatus.textContent = "Audio echo paused.";
            }
        };
        audioPlayer.onplaying = () => {
            ttsStatus.textContent = "Playing audio echo...";
        };

        // --- Event Listener for Text Selection in Story Output ---
        storyOutput.addEventListener('mouseup', async (event) => {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (selectedText.length > 2 && selectedText.length < 100 && storyOutput.contains(selection.anchorNode)) {
                showExplanationModal('Loading...', '', 'Fetching explanation...');
                const explanationData = await getExplanationForSelectedText(selectedText, currentTextStory);
                if (explanationData) {
                    explanationTerm.textContent = explanationData.term || selectedText;
                    explanationType.textContent = explanationData.type ? `(${explanationData.type})` : '';
                    explanationContent.textContent = explanationData.explanation || 'No explanation found.';
                } else {
                    explanationTerm.textContent = selectedText;
                    explanationType.textContent = '';
                    explanationContent.textContent = 'Could not retrieve explanation.';
                }
                showExplanationModal();
            }
        });

        // Add touch event listener for mobile selection
        storyOutput.addEventListener('touchend', async (event) => {
            event.preventDefault(); 
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (selectedText.length > 2 && selectedText.length < 100 && storyOutput.contains(selection.anchorNode)) {
                showExplanationModal('Loading...', '', 'Fetching explanation...');
                const explanationData = await getExplanationForSelectedText(selectedText, currentTextStory);
                if (explanationData) {
                    explanationTerm.textContent = explanationData.term || selectedText;
                    explanationType.textContent = explanationData.type ? `(${explanationData.type})` : '';
                    explanationContent.textContent = explanationData.explanation || 'No explanation found.';
                } else {
                    explanationTerm.textContent = selectedText;
                    explanationType.textContent = '';
                    explanationContent.textContent = 'Could not retrieve explanation.';
                }
                showExplanationModal();
            }
        });

        // --- Modal Control Functions ---
        function showExplanationModal(term = '', type = '', content = '') {
            if (term) explanationTerm.textContent = term;
            if (type) explanationType.textContent = type;
            if (content) explanationContent.textContent = content;
            explanationModal.classList.remove('hidden');
            explanationModal.classList.add('flex');
        }

        function hideExplanationModal() {
            explanationModal.classList.remove('flex');
            explanationModal.classList.add('hidden');
        }

        // Close modal when close button is clicked
        explanationCloseBtn.addEventListener('click', hideExplanationModal);

        // Close modal when clicking outside of it
        explanationModal.addEventListener('click', (event) => {
            if (event.target === explanationModal) {
                hideExplanationModal();
            }
        });

        // --- Camera Feature Event Listeners ---
        openCameraButton.addEventListener('click', async () => {
            errorMessage.classList.add('hidden');
            cameraStatus.textContent = "Requesting camera access...";
            cameraStatus.classList.remove('hidden');
            try {
                currentStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: { exact: "environment" }
                    }
                });
                cameraFeed.srcObject = currentStream;
                cameraFeedContainer.classList.remove('hidden');
                cameraFeedContainer.classList.add('flex');
                openCameraButton.classList.add('hidden');
                cameraStatus.textContent = "Camera active. Capture your moment!";
            } catch (err) {
                console.warn("Failed to access environment camera, trying user camera:", err);
                try {
                    currentStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    cameraFeed.srcObject = currentStream;
                    cameraFeedContainer.classList.remove('hidden');
                    cameraFeedContainer.classList.add('flex');
                    openCameraButton.classList.add('hidden');
                    cameraStatus.textContent = "Camera active (front camera). Capture your moment!";
                } catch (fallbackErr) {
                    console.error("Error accessing any camera:", fallbackErr);
                    cameraStatus.textContent = "Failed to access camera. Please ensure permissions are granted.";
                    displayError(`Camera access denied or error: ${fallbackErr.message}`);
                }
            }
        });

        capturePhotoButton.addEventListener('click', async () => {
            if (!cameraFeed.srcObject) {
                displayError("No camera feed active to capture from.");
                return;
            }

            cameraStatus.textContent = "Capturing photo...";
            const context = cameraCanvas.getContext('2d');
            cameraCanvas.width = cameraFeed.videoWidth;
            cameraCanvas.height = cameraFeed.videoHeight;
            context.drawImage(cameraFeed, 0, 0, cameraCanvas.width, cameraCanvas.height);

            const imageDataUrl = cameraCanvas.toDataURL('image/png');

            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null;
                currentStream = null;
            }
            cameraFeedContainer.classList.add('hidden');
            cameraFeedContainer.classList.remove('flex');
            openCameraButton.classList.remove('hidden');

            // Analyze the captured image for type and name
            const identifiedData = await analyzeImageForLocation(imageDataUrl);

            if (identifiedData && identifiedData.name) {
                // Set the input field with the identified name
                postcodeValue.value = identifiedData.name;
                // Now, trigger the form submission, passing the identified type as a custom event detail
                const customEvent = new CustomEvent('submit', {
                    cancelable: true,
                    bubbles: true,
                    detail: { identifiedType: identifiedData.type }
                });
                postcodeForm.dispatchEvent(customEvent);
            } else {
                cameraStatus.textContent = "Could not identify a clear object, human, or location from the image. Please try again or enter manually.";
                displayError("Image analysis failed to identify a clear artifact. Please try again or enter manually.");
            }
        });

        closeCameraButton.addEventListener('click', () => {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null;
                currentStream = null;
            }
            cameraFeedContainer.classList.add('hidden');
            cameraFeedContainer.classList.remove('flex');
            openCameraButton.classList.remove('hidden');
            cameraStatus.textContent = "";
        });

        document.addEventListener('DOMContentLoaded', () => {
            updateSearchHistoryPanel();
            document.getElementById('currentYear').textContent = new Date().getFullYear();
        });

    </script>

</body>
</html>
