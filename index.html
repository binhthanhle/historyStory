<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historical Story Finder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script type="module">
        // IMPORTANT: ESM (ECMAScript Module) for Gemini SDK (for text generation)
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

        // --- Firebase Configuration (Following platform guidelines) ---
        const appId = (typeof window.__app_id !== 'undefined') ? window.__app_id : 'default-app-id-story';
        const firebaseConfig = JSON.parse(
            (typeof window.__firebase_config !== 'undefined') ? window.__firebase_config : JSON.stringify({
                apiKey: "AIzaSyBnDQYvktbz1nsihJf2IZmObm47-3xjIPQ", // Replace with your actual Firebase API key
                authDomain: "test-firebase-4d1ff.firebaseapp.com", // Replace with your actual Firebase auth domain
                projectId: "test-firebase-4d1ff", // Replace with your actual Firebase project ID
                storageBucket: "test-firebase-4d1ff.firebasestorage.app", // Replace with your actual Firebase storage bucket
                messagingSenderId: "645698663286", // Replace with your actual Firebase messaging sender ID
                appId: "1:645698663286:web:3fa0f8ad2c70aa12e14057" // Replace with your actual Firebase app ID
            })
        );

        // --- Gemini API Key ---
        const GEMINI_API_KEY = "AIzaSyBpNS9buNt6TJOsWgr_zK0LtPW_Jx344-E"; // KEEP EMPTY TO USE PROVIDED KEY or gemini-2.0-flash

        // --- Google Cloud Text-to-Speech API Key ---
        // !!! IMPORTANT SECURITY WARNING !!!
        // For production, use a backend proxy to make this API call securely.
        const TTS_API_KEY = "AIzaSyBdkCTv_v-_1w47ij3eOAwXoCdhpMpA3FY"; // User-provided API key

        // --- Google Maps Geocoding API Key ---
        // !!! IMPORTANT SECURITY WARNING !!!
        // For production, use a backend proxy to make this API call securely.
        // You need to enable the "Geocoding API" in your Google Cloud Console for this key.
        const MAPS_API_KEY = "AIzaSyA8aeJmpoYdfmGTp-aMklJx2WkEIDdJplI"; // <<<<<<< REPLACE THIS WITH YOUR MAPS API KEY


        // Initialize Gemini Text Model (SDK)
        let textModel;
        if (GEMINI_API_KEY) {
            const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            textModel = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
        } else {
            // Attempt to use environment-provided SDK if key is not directly set (may only work for text)
            try {
                 const genAI = new GoogleGenerativeAI(""); // SDK might pick up env key
                 textModel = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
                 console.info("Attempting to use environment-provided Gemini SDK for text.");
            } catch (e) {
                console.error("Failed to initialize Gemini SDK without explicit API key.", e);
                // textModel will remain undefined, handled later
            }
        }


        // DOM Elements
        const postcodeForm = document.getElementById('postcodeForm');
        const postcodeValue = document.getElementById('postcode');
        const storyOutput = document.getElementById('storyOutput');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const audioButtonContainer = document.getElementById('audioButtonContainer');
        const playAudioButton = document.getElementById('playAudioButton');
        const audioPlayer = document.getElementById('audioPlayer');
        const ttsStatus = document.getElementById('ttsStatus');
        const errorMessage = document.getElementById('errorMessage');
        const imageContainer = document.getElementById('imageContainer');
        const geocodingStatus = document.getElementById('geocodingStatus');
        const imageGenStatus = document.getElementById('imageGenStatus');


        let currentTextStory = "";

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        postcodeForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const postcode = postcodeValue.value.trim();

            if (!postcode) { displayError("Please enter a postcode."); return; }
            if (!MAPS_API_KEY || MAPS_API_KEY === "YOUR_GOOGLE_MAPS_API_KEY_HERE") { displayError("Google Maps API Key is not configured."); return; }
            if (!textModel && !GEMINI_API_KEY) { displayError("Gemini API Key for text generation is not configured and SDK couldn't initialize."); return; }
             // Note: GEMINI_API_KEY is also used for image generation directly.

            // Clear UI
            storyOutput.innerHTML = '';
            imageContainer.innerHTML = '';
            audioButtonContainer.classList.add('hidden');
            audioPlayer.src = '';
            ttsStatus.textContent = ''; ttsStatus.classList.add('hidden');
            geocodingStatus.textContent = ''; geocodingStatus.classList.add('hidden');
            imageGenStatus.textContent = ''; imageGenStatus.classList.add('hidden');
            errorMessage.classList.add('hidden'); errorMessage.textContent = '';
            loadingIndicator.classList.remove('hidden');
            playAudioButton.disabled = false;

            let determinedLocation = postcode;

            try {
                // --- Step 1: Geocode Postcode ---
                geocodingStatus.textContent = `Geocoding postcode: ${postcode}...`;
                geocodingStatus.classList.remove('hidden');
                const geocodingUrl = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(postcode)}&key=${MAPS_API_KEY}`;
                const mapsResponse = await fetch(geocodingUrl);
                const mapsData = await mapsResponse.json();

                if (mapsData.status === "OK" && mapsData.results && mapsData.results.length > 0) {
                    determinedLocation = mapsData.results[0].formatted_address;
                    geocodingStatus.textContent = `Location identified: ${determinedLocation}`;
                } else {
                    geocodingStatus.textContent = `Could not geocode postcode. Using postcode directly. Status: ${mapsData.status}`;
                }

                // --- Step 2: Generate Historical Story (Text) ---
                if (!textModel) { // Check if textModel initialized (relevant if GEMINI_API_KEY was initially empty)
                    displayError("Gemini text model not available. Cannot generate story.");
                    loadingIndicator.classList.add('hidden');
                    return;
                }
                geocodingStatus.textContent += ` | Generating story...`; // Append to geocoding status
                const storyPrompt = `
                You are a historian and storyteller.
                A user has provided a location, identified as: "${determinedLocation}" (derived from the postcode "${postcode}").

                Your tasks are:
                1.  Based on this determined area ("${determinedLocation}"), find relevant historical information, notable events, figures, or developments.
                2.  Write an interesting and concise historical story about this area. Be direct and focus on the narrative. Avoid conversational fluff.
                3.  The story must be in Markdown format and include a suitable title.
                4.  Crucially, include a line at the VERY END of your entire response formatted EXACTLY like this (do not add any text after this line):
                    Image Suggestion: [A brief, descriptive caption for a relevant historical image, e.g., "A 19th-century map of the Sandyford area showing early farmlands" or "An early 20th-century photograph of Buckingham Palace exterior"]
                5. Do not include the text "\`\`\`markdown"
                If you cannot find specific historical information for "${determinedLocation}", try to find information for the broader town/city or region it belongs to, clearly stating this in the story. If no relevant historical information can be reasonably found, respond with a polite message in Markdown, still including the "Image Suggestion: [No specific image due to lack of historical data for ${determinedLocation}]" line at the very end.
                                `;

                const storyResult = await textModel.generateContent(storyPrompt);
                const storyResponse = await storyResult.response;
                currentTextStory = storyResponse.text();
                storyOutput.innerHTML = convertMarkdownToHtml(currentTextStory);
                geocodingStatus.textContent = `Location: ${determinedLocation} | Story generated.`;


                // --- Step 3: Generate Image based on Story ---
                if (!GEMINI_API_KEY) {
                    imageGenStatus.textContent = "Gemini API Key needed for image generation. Skipping image.";
                    imageGenStatus.classList.remove('hidden');
                    console.warn("GEMINI_API_KEY is empty, skipping image generation.");
                    // Optionally display a placeholder if no API key for images
                    const placeholderMsg = encodeURIComponent("Image generation skipped (API key missing)");
                    imageContainer.innerHTML = `<img src="https://placehold.co/600x400/666666/FFFFFF?text=${placeholderMsg}&font=lora" alt="Image generation skipped" class="mx-auto my-4 rounded-lg shadow-md max-w-full h-auto object-contain" style="max-height: 300px;">`;
                } else {
                    imageGenStatus.textContent = "Generating image based on the story...";
                    imageGenStatus.classList.remove('hidden');

                    // Create a concise prompt for image generation from the story
                    const imagePromptText = `Generate a historically relevant and visually compelling image that captures the essence of the following story. Focus on key elements or the overall mood. Story: "${convertMarkdownToPlainText(currentTextStory).substring(0, 500)}..."`; // Limit prompt length

                    const imageApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${GEMINI_API_KEY}`;
                    const imagePayload = {
                        instances: [{ prompt: imagePromptText }],
                        parameters: { "sampleCount": 1 }
                    };

                    const imageGenResponse = await fetch(imageApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(imagePayload)
                    });

                    if (!imageGenResponse.ok) {
                        const errorDetail = await imageGenResponse.text();
                        console.error("Image generation API error response:", errorDetail);
                        throw new Error(`Image generation failed: ${imageGenResponse.status} ${imageGenResponse.statusText}. Check console for details. Ensure your API key has 'imagen-3.0-generate-002' enabled.`);
                    }

                    const imageData = await imageGenResponse.json();

                    if (imageData.predictions && imageData.predictions.length > 0 && imageData.predictions[0].bytesBase64Encoded) {
                        const base64ImageData = imageData.predictions[0].bytesBase64Encoded;
                        const imageUrl = `data:image/png;base64,${base64ImageData}`;
                        imageContainer.innerHTML = `<img src="${imageUrl}" alt="AI-generated image for the story" class="mx-auto my-4 rounded-lg shadow-md max-w-full h-auto object-contain" style="max-height: 400px;">`;
                        imageGenStatus.textContent = "Image generated successfully.";
                    } else {
                        console.error("No image data received or unexpected format:", imageData);
                        imageGenStatus.textContent = "Failed to get image data from API.";
                         const placeholderMsg = encodeURIComponent("Image generation failed");
                        imageContainer.innerHTML = `<img src="https://placehold.co/600x400/E07A5F/FFFFFF?text=${placeholderMsg}&font=lora" alt="Image generation failed" class="mx-auto my-4 rounded-lg shadow-md max-w-full h-auto object-contain" style="max-height: 300px;">`;
                    }
                }
                audioButtonContainer.classList.remove('hidden');

            } catch (error) {
                console.error("Error during processing:", error);
                displayError(`Sorry, an error occurred: ${error.message}. Check console for details.`);
                imageContainer.innerHTML = ''; // Clear image on error
                geocodingStatus.classList.add('hidden');
                imageGenStatus.classList.add('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        });

        playAudioButton.addEventListener('click', async () => {
            if (!currentTextStory) { ttsStatus.textContent = "No story available."; ttsStatus.classList.remove('hidden'); return; }
            if (!TTS_API_KEY || TTS_API_KEY === "YOUR_GOOGLE_TTS_API_KEY_HERE") {
                ttsStatus.textContent = "TTS API Key not configured."; ttsStatus.classList.remove('hidden'); return;
            }

            const plainTextForTTS = convertMarkdownToPlainText(currentTextStory);
            playAudioButton.disabled = true;
            ttsStatus.textContent = "Generating audio..."; ttsStatus.classList.remove('hidden');
            audioPlayer.src = '';

            const ttsUrl = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${TTS_API_KEY}`;
            const requestBody = {
                input: { text: plainTextForTTS.substring(0, 4999) },
                voice: { languageCode: 'en-GB', name: 'en-GB-Wavenet-A', ssmlGender: 'FEMALE' },
                audioConfig: { audioEncoding: 'MP3' }
            };

            try {
                const ttsResponse = await fetch(ttsUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
                if (!ttsResponse.ok) { const err = await ttsResponse.json(); throw new Error(`TTS API: ${err.error?.message || ttsResponse.statusText}`); }
                const resData = await ttsResponse.json();
                if (resData.audioContent) {
                    audioPlayer.src = `data:audio/mp3;base64,${resData.audioContent}`;
                    audioPlayer.play();
                    ttsStatus.textContent = "Playing audio...";
                } else { throw new Error("No audio content from TTS API."); }
            } catch (err) {
                console.error("TTS Error:", err);
                ttsStatus.textContent = `TTS Error: ${err.message.substring(0,100)}`;
                displayError(`TTS failed. Key valid & API enabled?`);
            } finally {
                playAudioButton.disabled = false;
            }
        });

        audioPlayer.onended = () => { ttsStatus.textContent = "Audio finished."; };
        audioPlayer.onerror = () => { ttsStatus.textContent = "Error playing audio."; playAudioButton.disabled = false; };
        audioPlayer.onpause = () => { if (audioPlayer.currentTime > 0 && !audioPlayer.ended) ttsStatus.textContent = "Audio paused."; };
        audioPlayer.onplaying = () => { ttsStatus.textContent = "Playing audio..."; };

        function displayError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function convertMarkdownToPlainText(markdown) {
            let text = markdown;
            text = text.replace(/^#+\s+(.*)/gm, '$1. ');
            text = text.replace(/[\*_]{1,2}(.*?)[*_]{1,2}/g, '$1');
            text = text.replace(/!\[(.*?)\]\(.*?\)/g, '$1');
            text = text.replace(/\[(.*?)\]\(.*?\)/g, '$1');
            text = text.replace(/^\s*[\*\-\+]\s+/gm, '');
            text = text.replace(/\n\s*\n/g, '. ');
            text = text.replace(/\n/g, ' ');
            text = text.replace(/\s+/g, ' ').trim();
            return text;
        }

        function convertMarkdownToHtml(markdown) {
            let html = markdown;
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            html = html.replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>');
            html = html.replace(/__(.*?)__/gim, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/gim, '<em>$1</em>');
            html = html.replace(/_(.*?)_/gim, '<em>$1</em>');
            
            html = html.replace(/^\s*[\*\-\+]\s+(.*)/gim, (match, item) => `<li>${item}</li>`);
            let inList = false;
            html = html.split('\n').map(line => {
                if (line.startsWith('<li>') && !inList) { inList = true; return '<ul>' + line; }
                if (!line.startsWith('<li>') && inList) { inList = false; return '</ul>' + line; }
                return line;
            }).join('\n');
            if (inList) html += '</ul>';

            html = html.split(/\n\s*\n/).map(paragraph => {
                const trimmed = paragraph.trim();
                if (!trimmed) return '';
                if (trimmed.match(/^<(h[1-6]|ul|ol|li|blockquote|pre|hr)/i)) return trimmed;
                return `<p>${trimmed.replace(/\n/g, '<br>')}</p>`;
            }).join('');
            html = html.replace(/<p><\/p>/g, '').replace(/<p><br\s*\/?>\s*<\/p>/gi, '');
            return html;
        }

    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #storyOutput h1 { font-size: 1.875rem; font-weight: bold; margin-top: 1rem; margin-bottom: 0.5rem; }
        #storyOutput h2 { font-size: 1.5rem; font-weight: bold; margin-top: 0.875rem; margin-bottom: 0.4rem; }
        #storyOutput h3 { font-size: 1.25rem; font-weight: bold; margin-top: 0.75rem; margin-bottom: 0.3rem; }
        #storyOutput p { margin-bottom: 1rem; line-height: 1.6; }
        #storyOutput strong { font-weight: bold; }
        #storyOutput em { font-style: italic; }
        #storyOutput ul { list-style-type: disc; margin-left: 1.5rem; margin-bottom: 1rem; padding-left: 1rem;}
        #storyOutput li { margin-bottom: 0.25rem; }
        #audioPlayer { margin-top: 0.5rem; width: 100%; border-radius: 0.375rem; }
        #imageContainer img { display: block; }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 text-slate-100 min-h-screen flex flex-col items-center justify-center p-4 selection:bg-sky-500 selection:text-white">

    <div class="bg-slate-800 shadow-2xl rounded-xl p-6 md:p-10 w-full max-w-2xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-sky-400">Historical Story Finder</h1>
            <p class="text-slate-400 mt-2">Enter a postcode to discover historical stories from its vicinity, with an AI-generated image.</p>
        </header>

        <form id="postcodeForm" class="space-y-6">
            <div>
                <label for="postcode" class="block text-sm font-medium text-sky-300 mb-1">Postcode</label>
                <input type="text" name="postcode" id="postcode" required
                       class="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-slate-100 focus:ring-2 focus:ring-sky-500 focus:border-sky-500 outline-none transition-all"
                       placeholder="e.g., SW1A 1AA or D16 TX97">
            </div>
            <button type="submit"
                    class="w-full bg-sky-600 hover:bg-sky-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:shadow-lg transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-50">
                Discover History
            </button>
        </form>

        <div id="loadingIndicator" class="mt-8 text-center hidden">
            <div class="inline-flex items-center">
                <svg class="animate-spin -ml-1 mr-3 h-6 w-6 text-sky-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span class="text-slate-300">Processing...</span>
            </div>
        </div>
        
        <p id="geocodingStatus" class="mt-4 text-sm text-sky-300 text-center hidden"></p>
        <p id="imageGenStatus" class="mt-2 text-sm text-sky-300 text-center hidden"></p>


        <div id="errorMessage" class="mt-6 bg-red-700/30 border border-red-600 text-red-300 px-4 py-3 rounded-lg hidden" role="alert">
        </div>
        
        <div id="imageContainer" class="mt-6 text-center">
        </div>

        <article id="storyOutput" class="mt-4 prose prose-invert max-w-none text-slate-200">
        </article>

        <div id="audioButtonContainer" class="mt-8 text-center hidden">
            <button id="playAudioButton"
                    class="bg-emerald-600 hover:bg-emerald-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:shadow-lg transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed">
                ▶️ Read Aloud
            </button>
            <p id="ttsStatus" class="text-sm text-slate-400 mt-2 hidden"></p>
            <audio id="audioPlayer" controls class="mt-3 w-full rounded-md"></audio>
            <p class="text-xs text-slate-500 mt-2">
                <strong class="text-amber-400">Warning:</strong> API keys are exposed client-side. For production, use a secure backend.
            </p>
        </div>
    </div>

    <footer class="text-center text-slate-500 mt-12 text-sm">
        <p>&copy; <span id="currentYear"></span> Historical Story Finder. Powered by Gemini, Google Maps & Google Cloud TTS.</p>
    </footer>
    <script>
        document.getElementById('currentYear').textContent = new Date().getFullYear();
    </script>

</body>
</html>
