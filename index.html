<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echoes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Apply Inter font globally */
        body { font-family: 'Inter', sans-serif; }

        /* Custom styles for Markdown rendered content within the story output */
        /* These styles enhance readability and visual hierarchy for generated stories */
        .prose h1 { font-size: 1.875rem; font-weight: bold; margin-top: 1.5rem; margin-bottom: 0.75rem; color: #60A5FA; /* Sky-400 equivalent */ }
        .prose h2 { font-size: 1.5rem; font-weight: bold; margin-top: 1.25rem; margin-bottom: 0.6rem; color: #93C5FD; /* Sky-300 equivalent */ }
        .prose h3 { font-size: 1.25rem; font-weight: bold; margin-top: 1rem; margin-bottom: 0.5rem; color: #BFDBFE; /* Sky-200 equivalent */ }
        .prose p { margin-bottom: 1rem; line-height: 1.75; } /* Increased line-height for better readability */
        .prose strong { font-weight: bold; color: #E0F2FE; /* Lighter sky for emphasis */ }
        .prose em { font-style: italic; color: #BEE3F8; /* Even lighter sky for subtle emphasis */ }
        .prose ul { list-style-type: disc; margin-left: 1.5rem; margin-bottom: 1rem; padding-left: 1rem;}
        .prose li { margin-bottom: 0.5rem; } /* Increased spacing for list items */
        
        /* Ensure audio player and image container maintain good spacing and appearance */
        #audioPlayer { margin-top: 1rem; width: 100%; border-radius: 0.5rem; background-color: #334155; }
        #imageContainer img { display: block; } /* Ensures image is a block element */

        /* Styles for the clickable "Explore Further" buttons at the bottom of the story */
        .highlighted-term-button {
            /* Tailwind classes applied directly for consistency */
            @apply bg-sky-700/20 text-sky-300 hover:bg-sky-600/40 px-3 py-1 rounded-full text-sm font-medium transition-colors duration-300 ease-in-out;
            white-space: nowrap; /* Prevent wrapping for single terms */
        }

        /* Main layout container for panels - uses flexbox for responsive side-by-side or stacked layout */
        #main-content-container {
            display: flex;
            flex-direction: column; /* Default to stacking on small screens */
            gap: 1.5rem; /* Space between left and right panels */
            width: 100%;
            max-width: 80rem; /* Increased max-width for more content space on large screens */
            margin: 0 auto; /* Center the container */
        }

        /* Left Panel: Search History */
        #searchHistoryPanel {
            flex: 0 0 auto; /* Don't grow, don't shrink */
            width: 100%; /* Full width on small screens */
            background-color: #1e293b; /* Slate-800 equivalent */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-2xl */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1.5rem;
            align-self: flex-start; /* Align to top */
            max-height: 90vh; /* Limit height for scrolling */
            overflow-y: auto; /* Enable scrolling for history list */
        }
        #searchHistoryPanel ul {
            list-style: none;
            padding: 0;
        }
        #searchHistoryPanel button {
            text-align: left;
        }

        /* Right Panel: Form and Story Display (now combined) */
        #right-content-area {
            flex: 1; /* Take remaining space */
            display: flex;
            flex-direction: column;
            background-color: #1e293b; /* Slate-800 equivalent */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-2xl */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1.5rem;
        }

        /* Modal Styles for explanations */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top of other content */
        }

        .modal-content {
            background-color: #1e293b; /* Slate-800 */
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            max-width: 500px;
            width: 90%; /* Responsive width */
            color: #E2E8F0; /* Slate-200 */
            position: relative;
            animation: fadeInScale 0.3s ease-out forwards; /* Add simple animation */
        }

        /* Keyframe animation for modal */
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-close-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #94A3B8; /* Slate-400 */
            cursor: pointer;
            transition: color 0.2s;
        }
        .modal-close-btn:hover {
            color: #CBD5E1; /* Slate-300 */
        }

        /* Responsive adjustments for larger screens */
        @media (min-width: 768px) { /* md breakpoint */
            #main-content-container {
                flex-direction: row; /* Side-by-side on larger screens */
            }
            #searchHistoryPanel {
                width: 25%; /* Left panel takes 1/4th width */
            }
            #right-content-area {
                width: 75%; /* Right panel takes 3/4th width */
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 text-slate-100 min-h-screen flex flex-col items-center justify-center p-4 selection:bg-sky-500 selection:text-white">

    <audio autoplay loop style="display:none;">
      <source src="LandingPageMusic.mp3" type="audio/mp3">
    </audio>

    <div id="main-content-container" class="container mx-auto">
        <aside id="searchHistoryPanel" class="hidden md:block">
            <h2 class="text-2xl font-bold text-sky-400 mb-4 text-center">Search History</h2>
            <ul id="historyList" class="w-full space-y-2"></ul>
        </aside>

        <main id="right-content-area">
            <header class="text-center mb-8">
                <img src="https://raw.githubusercontent.com/binhthanhle/historyStory/refs/heads/main/Gemini_Generated_Image_8fpqr08fpqr08fpq.png" 
                     alt="Echoes App Logo" 
                     class="h-20 mx-auto mb-4 rounded-lg"
                     onerror="this.onerror=null; this.src='https://placehold.co/150x64/60A5FA/FFFFFF?text=Echoes&font=Inter';">
                <p class="text-slate-400 mt-2">Uncover the whispers of the past. Enter a name, object, or place to hear its historical echoes and glimpse its story.</p>
            </header>

            <form id="postcodeForm" class="space-y-6 mb-8">
                <div>
                    <label for="postcode" class="block text-sm font-medium text-sky-300 mb-1">Artifact (e.g., Name, Postcode, City, Landmark)</label>
                    <input type="text" name="postcode" id="postcode" required
                            class="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg text-slate-100 focus:ring-2 focus:ring-sky-500 focus:border-sky-500 outline-none transition-all"
                            placeholder="e.g., London, Eiffel Tower, D04 E5W5">
                </div>
                <button type="submit"
                        class="w-full bg-sky-600 hover:bg-sky-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:shadow-lg transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-50">
                Unveil the Past
                </button>
            </form>

            <section class="mt-8 p-6 bg-slate-700 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold text-sky-400 mb-4 text-center">Capture a Moment</h2>
                <div class="flex justify-center mb-4 space-x-4">
                    <button id="openCameraButton" class="bg-indigo-600 hover:bg-indigo-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                        Open Camera
                    </button>
                    <button id="uploadImageButton" class="bg-purple-600 hover:bg-purple-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50">
                        Upload Image
                    </button>
                    <input type="file" id="imageUploadInput" accept="image/*" class="hidden">
                </div>

                <div id="cameraFeedContainer" class="hidden flex-col items-center">
                    <video id="cameraFeed" class="w-full max-w-md rounded-lg border border-slate-600 shadow-md" autoplay></video>
                    <canvas id="cameraCanvas" class="hidden"></canvas>
                    <button id="capturePhotoButton" class="mt-4 bg-green-600 hover:bg-green-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">
                        Capture Photo
                    </button>
                    <button id="closeCameraButton" class="mt-2 bg-red-600 hover:bg-red-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50">
                        Close Camera
                    </button>
                    <p id="cameraStatus" class="mt-2 text-sm text-sky-300 text-center"></p>
                </div>
            </section>

            <div id="loadingIndicator" class="mt-8 text-center hidden">
                <div class="inline-flex items-center">
                    <svg class="animate-spin -ml-1 mr-3 h-6 w-6 text-sky-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="1": "STRING" },
                                "type": { "type": "STRING" },
                                "explanation": { "type": "STRING" }
                            },
                            required: ["term", "type", "explanation"]
                        }
                    }
                };

                const apiKey = GEMINI_API_KEY === "YOUR_GEMINI_API_KEY" ? "" : GEMINI_API_KEY;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorDetails = await response.text();
                    throw new Error(`Explanation API error: ${response.status} ${response.statusText} - ${errorDetails}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonString = result.candidates[0].content.parts[0].text;
                    try {
                        const explanationData = JSON.parse(jsonString);
                        return explanationData;
                    } catch (parseError) {
                        console.error("Failed to parse LLM explanation response as JSON:", jsonString, parseError);
                        return [];
                    }
                } else {
                    console.warn("No explanation content from LLM:", result);
                    return [];
                }
            } catch (error) {
                console.error("Error during explanation generation:", error);
                displayError(`Failed to get explanation: ${error.message}`);
                return [];
            }
        }

        /**
         * Updates the search history panel with the latest search terms.
         * Limits the history to 10 unique items.
         */
        function updateSearchHistoryPanel() {
            // Clear existing list
            searchHistoryPanel.innerHTML = `
                <h2 class="text-2xl font-bold text-sky-400 mb-4 text-center">Search History</h2>
                <ul id="historyList" class="w-full space-y-2"></ul>
            `;
            const historyList = document.getElementById('historyList');

            // Add unique terms to history, limit to 10
            const uniqueHistory = Array.from(new Set(searchHistory)); // Ensure uniqueness
            searchHistory = uniqueHistory.slice(0, 10); // Limit to 10 most recent unique searches

            searchHistory.forEach(term => {
                const listItem = document.createElement('li');
                const button = document.createElement('button');
                button.textContent = term;
                button.classList.add('w-full', 'text-left', 'px-3', 'py-2', 'rounded-md', 'transition-colors', 'duration-200', 'text-sky-300', 'hover:bg-slate-700');
                button.setAttribute('data-term', term);
                button.addEventListener('click', () => {
                    postcodeValue.value = term; // Set the input field
                    postcodeForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true })); // Trigger form submission
                });
                listItem.appendChild(button);
                historyList.appendChild(listItem);
            });
        }

        /**
         * Analyzes a base64 encoded image to identify a relevant term (landmark, historic object, or historic human) using Gemini Vision API.
         * Prioritizes landmark, then historic object, then historic human.
         * @param {string} base64ImageData The base64 encoded image data (e.g., "data:image/png;base64,...").
         * @returns {Promise<string|null>} A promise that resolves to the identified term string or null if not found.
         */
        async function analyzeImageForLocation(base64ImageData) {
            cameraStatus.textContent = "Analyzing image for landmark, historic object, or historic human...";
            loadingIndicator.classList.remove('hidden');

            if (!GEMINI_API_KEY || GEMINI_API_KEY === "" || GEMINI_API_KEY === "YOUR_GEMINI_API_KEY") {
                cameraStatus.textContent = "Gemini API Key for image analysis is not configured. Cannot analyze image.";
                displayError("Gemini API Key needed for image analysis. Please configure it.");
                loadingIndicator.classList.add('hidden');
                return null;
            }

            // Extract just the base64 data part, removing the "data:image/png;base64," prefix
            const dataPart = base64ImageData.split(',')[1];
            if (!dataPart) {
                displayError("Invalid image data provided for analysis.");
                loadingIndicator.classList.add('hidden');
                return null;
            }

            // REVISED PROMPT to prioritize landmark, then historic object, then historic human
            const prompt = `
                If the picture is clearly a landmark, Monument, Pillar, or scene, figure out where that is, return back the name of the landmark, Monument, Pillar, or scene.
                If the picture is clearly an object in history, like a statue, Sculpture, ancient picture, etc., figure out what is or who is that object, return the name.
                If the picture is clearly a modern object, like a Coca-Cola bottle, a product, etc., figure out what is that product's company and related to the area of the origin.
                Do not make up story.
                Provide only the identified term and nothing else.
            `;

            try {
                const payload = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                { text: prompt },
                                {
                                    inlineData: {
                                        mimeType: "image/png", // Assuming PNG from canvas
                                        data: dataPart
                                    }
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: 0.2, // Keep it focused
                    }
                };

                const apiKey = GEMINI_API_KEY === "YOUR_GEMINI_API_KEY" ? "" : GEMINI_API_KEY;
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorDetails = await response.text();
                    throw new Error(`Image analysis API error: ${response.status} ${response.statusText} - ${errorDetails}`);
                }

                const result = await response.json();
                loadingIndicator.classList.add('hidden');

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const identifiedTerm = result.candidates[0].content.parts[0].text.trim();
                    cameraStatus.textContent = `Identified: ${identifiedTerm}`;
                    return identifiedTerm;
                } else {
                    cameraStatus.textContent = "No clear landmark, historic object, or historic human identified from image. Please try again or enter manually.";
                    return null;
                }
            } catch (error) {
                console.error("Error during image analysis:", error);
                displayError(`Failed to analyze image for object/human/location: ${error.message}`);
                loadingIndicator.classList.add('hidden');
                return null;
            }
        }


        // Event listener for form submission (existing logic, now potentially called by camera or image upload)
        postcodeForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const postcode = postcodeValue.value.trim(); // This will be the location from text input OR from camera/image upload

            // Add current search term to history (if not empty and not already the first item)
            if (postcode && (searchHistory.length === 0 || searchHistory[0] !== postcode)) {
                searchHistory.unshift(postcode); // Add to the beginning
                searchHistory = searchHistory.slice(0, 10); // Keep only the latest 10
                updateSearchHistoryPanel();
            }

            // --- Check cache first ---
            if (storyCache.has(postcode)) {
                const cachedData = storyCache.get(postcode);
                storyOutput.innerHTML = cachedData.htmlStory;
                imageContainer.innerHTML = `<img src="${cachedData.imageUrl}" alt="AI-generated image for the story" class="mx-auto my-4 rounded-lg shadow-md max-w-full h-auto object-contain" style="max-height: 400px;">`;
                currentTextStory = cachedData.rawMarkdown;

                // Re-render explore further buttons from cached entities
                const exploreFurtherDiv = document.getElementById('exploreFurtherButtons');
                exploreFurtherDiv.innerHTML = ''; // Clear existing buttons
                const termsTitle = document.createElement('h3');
                termsTitle.classList.add('text-lg', 'font-semibold', 'text-sky-300', 'mb-3');
                termsTitle.textContent = 'Explore Further:';
                exploreFurtherDiv.appendChild(termsTitle);

                if (cachedData.entities && cachedData.entities.length > 0) {
                    const termsFlexContainer = document.createElement('div');
                    termsFlexContainer.classList.add('flex', 'flex-wrap', 'gap-2');
                    cachedData.entities.forEach(term => {
                        const termButton = document.createElement('button');
                        termButton.classList.add('highlighted-term-button', 'bg-sky-700/20', 'text-sky-300', 'hover:bg-sky-600/40', 'px-3', 'py-1', 'rounded-full', 'text-sm', 'font-medium', 'transition-colors');
                        termButton.textContent = term;
                        termButton.setAttribute('data-term', term);
                        termButton.addEventListener('click', () => {
                            postcodeValue.value = term; // Set the input field
                            postcodeForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true })); // Trigger form submission
                        });
                        termsFlexContainer.appendChild(termButton);
                    });
                    exploreFurtherDiv.appendChild(termsFlexContainer);
                } else {
                    const noTerms = document.createElement('p');
                    noTerms.classList.add('text-slate-400', 'text-sm');
                    noTerms.textContent = 'No specific terms identified for further exploration.';
                    exploreFurtherDiv.appendChild(noTerms);
                }

                await synthesizeAndPlayAudio(currentTextStory, audioPlayer, ttsStatus);
                geocodingStatus.textContent = `Loaded from cache: ${postcode}`;
                geocodingStatus.classList.remove('hidden');
                imageGenStatus.classList.add('hidden'); // Hide image gen status when loading from cache
                errorMessage.classList.add('hidden');
                loadingIndicator.classList.add('hidden');
                return; // Exit early if loaded from cache
            }


            // Input validation and API key checks (only if not loaded from cache)
            if (!postcode) { displayError("Please enter an artifact."); return; }
            if (!MAPS_API_KEY || MAPS_API_KEY === "" || MAPS_API_KEY === "YOUR_MAPS_API_KEY") { displayError("Google Maps API Key is not configured. Geocoding will be skipped."); /* Continue without geocoding if key is missing */ }
            if (!textModel && (GEMINI_API_KEY === "" || GEMINI_API_KEY === "YOUR_GEMINI_API_KEY")) { displayError("Gemini API Key for text generation is not configured and SDK couldn't initialize."); return; }

            // Clear global status messages and show loading indicator
            geocodingStatus.textContent = ''; geocodingStatus.classList.add('hidden');
            imageGenStatus.textContent = ''; imageGenStatus.classList.add('hidden');
            errorMessage.classList.add('hidden'); errorMessage.textContent = '';
            loadingIndicator.classList.remove('hidden');

            let determinedLocation = postcode; // Default to raw postcode if geocoding fails or skipped

            try {
                // --- Step 1: Geocode Postcode (if API key is available) ---
                if (MAPS_API_KEY && MAPS_API_KEY !== "" || MAPS_API_KEY === "YOUR_MAPS_API_KEY") {
                    geocodingStatus.textContent = `Attempting to pinpoint for: ${postcode}...`;
                    geocodingStatus.classList.remove('hidden');
                    const geocodingUrl = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(postcode)}&key=${MAPS_API_KEY}`;
                    const mapsResponse = await fetch(geocodingUrl);
                    const mapsData = await mapsResponse.json();

                    if (mapsData.status === "OK" && mapsData.results && mapsData.results.length > 0) {
                        determinedLocation = mapsData.results[0].formatted_address;
                        geocodingStatus.textContent = `Information revealed: ${determinedLocation}`;
                    } else {
                        // If geocoding fails, determinedLocation remains the original postcode.
                        // The status message is now handled by the general "Weaving a tale" message below.
                    }
                } else {
                    // If Maps API key is missing, determinedLocation remains the original postcode.
                    // The status message is now handled by the general "Weaving a tale" message below.
                }

                // --- Step 2: Generate Historical Story (Text) ---
                if (!textModel) { // Check if textModel initialized (relevant if GEMINI_API_KEY was initially empty)
                    displayError("Gemini text model not available. Cannot weave a story.");
                    loadingIndicator.classList.add('hidden');
                    return;
                }
                // Only append to geocodingStatus if it's not hidden (i.e., if geocoding was attempted)
                if (!geocodingStatus.classList.contains('hidden')) {
                    geocodingStatus.textContent += ` | Weaving a tale...`; 
                } else {
                    // If geocoding was skipped/failed silently, show a general weaving message
                    geocodingStatus.textContent = `Weaving a tale for: ${determinedLocation}...`;
                    geocodingStatus.classList.remove('hidden');
                }
                
                const storyPrompt = `
                You are a historian and storyteller.
                A user has provided an artifact, identified as: "${determinedLocation}" 
                (derived from the original input "${postcode}").

                Your tasks are:
                1.  Based on this determined artifact ("${determinedLocation}"), 
                    find relevant historical information, notable events, figures, or developments.
                2.  Write an interesting and concise historical story about this artifact.
                3.  The story must be in Markdown format and include a suitable title.
                4.  Do not include any "Image Suggestion:" line at the end of your response.
                5.  Keep the context as a story on the book, good reading, 
                    without explicitly using "What?", "Where?", "When?", "Who?", "Why?", and "How?" 
                    as section headers or direct questions within the narrative. 
                    Instead, weave the answers to these questions naturally into the story's flow.
                6.  Format the text as the book content, beware to remove all \` (backward) symbols on the context and word 'markdown' next to it
                7.  If you cannot find specific historical information for "${determinedLocation}", 
                try to find information for the broader context (e.g., town/city or region it belongs to), 
                clearly stating this in the story. 
                8.  If no relevant historical information can be reasonably found, respond with a polite message in Markdown.
                                `;

                const storyResult = await textModel.generateContent(storyPrompt);
                const storyResponse = await storyResult.response;
                let fullStoryText = storyResponse.text();

                currentTextStory = fullStoryText.trim(); 

                // --- Step 3: Extract Entities ---
                imageGenStatus.textContent = `Identifying key terms...`;
                const entitiesToHighlight = await extractEntitiesForHighlighting(currentTextStory);
                
                // --- Step 4: Generate Image based on Story ---
                let imageUrl = `https://placehold.co/600x400/E07A5F/FFFFFF?text=${encodeURIComponent("Image generation failed")}&font=lora`; // Default placeholder
                if (GEMINI_API_KEY === "" || GEMINI_API_KEY === "YOUR_GEMINI_API_KEY") { // Check if GEMINI_API_KEY is empty/default for image generation
                    imageGenStatus.textContent = "Gemini API Key needed for visual echoes. Skipping image generation.";
                    imageGenStatus.classList.remove('hidden');
                    console.warn("GEMINI_API_KEY is empty or default, skipping image generation.");
                    const placeholderMsg = encodeURIComponent("Image generation skipped (API key missing)");
                    imageUrl = `https://placehold.co/600x400/666666/FFFFFF?text=${placeholderMsg}&font=lora`;
                } else {
                    imageGenStatus.textContent = "Conjuring a visual echo...";
                    imageGenStatus.classList.remove('hidden');

                    let imagePromptText = `Generate a historically relevant and visually compelling image that captures the essence of the following story. Focus on key elements or the overall mood. Story: "${convertMarkdownToPlainText(currentTextStory).substring(0, 500)}..."`;

                    const imageApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${GEMINI_API_KEY}`;
                    const imagePayload = {
                        instances: [{ prompt: imagePromptText }],
                        parameters: { "sampleCount": 1 }
                    };

                    const imageGenResponse = await fetch(imageApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(imagePayload)
                    });

                    if (!imageGenResponse.ok) {
                        const errorDetail = await imageGenResponse.text();
                        console.error("Image generation API error response:", errorDetail);
                        displayError(`Image generation failed: ${imageGenResponse.status} ${imageGenResponse.statusText}. Check console for details. Ensure your API key has 'imagen-3.0-generate-002' enabled.`);
                    } else {
                        const imageData = await imageGenResponse.json();
                        if (imageData.predictions && imageData.predictions.length > 0 && imageData.predictions[0].bytesBase64Encoded) {
                            imageUrl = `data:image/png;base64,${imageData.predictions[0].bytesBase64Encoded}`;
                            imageGenStatus.textContent = "Visual echo created.";
                        } else {
                            console.error("No image data received or unexpected format:", imageData);
                            imageGenStatus.textContent = "Failed to create visual echo.";
                        }
                    }
                }

                // --- Step 5: Display Story, Image, TTS Controls, and Explore Further Buttons ---
                const storyHtml = convertMarkdownToHtml(currentTextStory);
                storyOutput.innerHTML = storyHtml; // Update the single storyOutput div
                imageContainer.innerHTML = `<img src="${imageUrl}" alt="AI-generated image for the story" class="mx-auto my-4 rounded-lg shadow-md max-w-full h-auto object-contain" style="max-height: 400px;">`; // Update the single imageContainer div

                // Clear previous explore further buttons and add new ones
                const exploreFurtherDiv = document.getElementById('exploreFurtherButtons');
                exploreFurtherDiv.innerHTML = ''; // Clear existing buttons
                const termsTitle = document.createElement('h3');
                termsTitle.classList.add('text-lg', 'font-semibold', 'text-sky-300', 'mb-3');
                termsTitle.textContent = 'Explore Further:';
                exploreFurtherDiv.appendChild(termsTitle);

                if (entitiesToHighlight.length > 0) {
                    const termsFlexContainer = document.createElement('div');
                    termsFlexContainer.classList.add('flex', 'flex-wrap', 'gap-2');
                    entitiesToHighlight.forEach(term => {
                        const termButton = document.createElement('button');
                        termButton.classList.add('highlighted-term-button', 'bg-sky-700/20', 'text-sky-300', 'hover:bg-sky-600/40', 'px-3', 'py-1', 'rounded-full', 'text-sm', 'font-medium', 'transition-colors');
                        termButton.textContent = term;
                        termButton.setAttribute('data-term', term);
                        termButton.addEventListener('click', () => {
                            postcodeValue.value = term; // Set the input field
                            postcodeForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true })); // Trigger form submission
                        });
                        termsFlexContainer.appendChild(termButton);
                    });
                    exploreFurtherDiv.appendChild(termsFlexContainer);
                } else {
                    const noTerms = document.createElement('p');
                    noTerms.classList.add('text-slate-400', 'text-sm');
                    noTerms.textContent = 'No specific terms identified for further exploration.';
                    exploreFurtherDiv.appendChild(noTerms);
                }

                // --- Store in cache after successful generation ---
                storyCache.set(postcode, {
                    rawMarkdown: currentTextStory,
                    htmlStory: storyHtml,
                    imageUrl: imageUrl,
                    entities: entitiesToHighlight
                });

                // --- Step 6: Play TTS Audio for the new story ---
                await synthesizeAndPlayAudio(currentTextStory, audioPlayer, ttsStatus); // Use direct audioPlayer and ttsStatus

                geocodingStatus.textContent = `Information revealed: ${determinedLocation} | Story unveiled.`;

            } catch (error) {
                console.error("Error during processing:", error);
                displayError(`Sorry, an error occurred: ${error.message}. Check console for details.`);
                geocodingStatus.classList.add('hidden');
                imageGenStatus.classList.add('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        });

        // Audio player event listeners for status updates (for TTS audio)
        // These now directly target the single audioPlayer and ttsStatus elements
        audioPlayer.onended = () => {
            ttsStatus.textContent = "Audio echo finished.";
        };
        audioPlayer.onerror = () => {
            ttsStatus.textContent = "Error playing audio echo.";
        };
        audioPlayer.onpause = () => {
            if (audioPlayer.currentTime > 0 && !audioPlayer.ended) {
                ttsStatus.textContent = "Audio echo paused.";
            }
        };
        audioPlayer.onplaying = () => {
            ttsStatus.textContent = "Playing audio echo...";
        };

        // --- Event Listener for Text Selection in Story Output ---
        storyOutput.addEventListener('mouseup', async (event) => {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (selectedText.length > 2 && selectedText.length < 100 && storyOutput.contains(selection.anchorNode)) {
                // Only process if text is selected within the storyOutput and is a reasonable length
                showExplanationModal('Loading...', '', 'Fetching explanation...');
                const explanationData = await getExplanationForSelectedText(selectedText, currentTextStory);
                if (explanationData) {
                    explanationTerm.textContent = explanationData.term || selectedText;
                    explanationType.textContent = explanationData.type ? `(${explanationData.type})` : '';
                    explanationContent.textContent = explanationData.explanation || 'No explanation found.';
                } else {
                    explanationTerm.textContent = selectedText;
                    explanationType.textContent = '';
                    explanationContent.textContent = 'Could not retrieve explanation.';
                }
                showExplanationModal();
            }
        });

        // Add touch event listener for mobile selection
        storyOutput.addEventListener('touchend', async (event) => {
            // Prevent default touch behavior that might interfere with selection
            event.preventDefault(); 
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            // Check if text is selected and it's within the storyOutput element
            if (selectedText.length > 2 && selectedText.length < 100 && storyOutput.contains(selection.anchorNode)) {
                showExplanationModal('Loading...', '', 'Fetching explanation...');
                const explanationData = await getExplanationForSelectedText(selectedText, currentTextStory);
                if (explanationData) {
                    explanationTerm.textContent = explanationData.term || selectedText;
                    explanationType.textContent = explanationData.type ? `(${explanationData.type})` : '';
                    explanationContent.textContent = explanationData.explanation || 'No explanation found.';
                } else {
                    explanationTerm.textContent = selectedText;
                    explanationType.textContent = '';
                    explanationContent.textContent = 'Could not retrieve explanation.';
                }
                showExplanationModal();
            }
        });

        // --- Modal Control Functions ---
        function showExplanationModal(term = '', type = '', content = '') {
            if (term) explanationTerm.textContent = term;
            if (type) explanationType.textContent = type;
            if (content) explanationContent.textContent = content;
            explanationModal.classList.remove('hidden');
            explanationModal.classList.add('flex'); // Use flex to center
        }

        function hideExplanationModal() {
            explanationModal.classList.remove('flex');
            explanationModal.classList.add('hidden');
        }

        // Close modal when close button is clicked
        explanationCloseBtn.addEventListener('click', hideExplanationModal);

        // Close modal when clicking outside of it
        explanationModal.addEventListener('click', (event) => {
            if (event.target === explanationModal) {
                hideExplanationModal();
            }
        });

        // --- Camera Feature Event Listeners ---
        openCameraButton.addEventListener('click', async () => {
            errorMessage.classList.add('hidden');
            cameraStatus.textContent = "Requesting camera access...";
            cameraStatus.classList.remove('hidden');
            try {
                // Attempt to get the 'environment' (back) camera first
                currentStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: { exact: "environment" }
                    }
                });
                cameraFeed.srcObject = currentStream;
                cameraFeedContainer.classList.remove('hidden');
                cameraFeedContainer.classList.add('flex'); // Show as flex
                openCameraButton.classList.add('hidden');
                uploadImageButton.classList.add('hidden'); // Hide upload button when camera is open
                cameraStatus.textContent = "Camera active. Capture your moment!";
            } catch (err) {
                console.warn("Failed to access environment camera, trying user camera:", err);
                // Fallback to 'user' (front) camera if 'environment' fails
                try {
                    currentStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    cameraFeed.srcObject = currentStream;
                    cameraFeedContainer.classList.remove('hidden');
                    cameraFeedContainer.classList.add('flex'); // Show as flex
                    openCameraButton.classList.add('hidden');
                    uploadImageButton.classList.add('hidden'); // Hide upload button when camera is open
                    cameraStatus.textContent = "Camera active (front camera). Capture your moment!";
                } catch (fallbackErr) {
                    console.error("Error accessing any camera:", fallbackErr);
                    cameraStatus.textContent = "Failed to access camera. Please ensure permissions are granted.";
                    displayError(`Camera access denied or error: ${fallbackErr.message}`);
                }
            }
        });

        capturePhotoButton.addEventListener('click', async () => {
            if (!cameraFeed.srcObject) {
                displayError("No camera feed active to capture from.");
                return;
            }

            cameraStatus.textContent = "Capturing photo...";
            const context = cameraCanvas.getContext('2d');
            // Set canvas dimensions to match video feed
            cameraCanvas.width = cameraFeed.videoWidth;
            cameraCanvas.height = cameraFeed.videoHeight;
            // Draw the current video frame onto the canvas
            context.drawImage(cameraFeed, 0, 0, cameraCanvas.width, cameraCanvas.height);

            // Get the image data as a Base64 encoded PNG
            const imageDataUrl = cameraCanvas.toDataURL('image/png');

            // Stop the camera stream
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null;
                currentStream = null;
            }
            cameraFeedContainer.classList.add('hidden');
            cameraFeedContainer.classList.remove('flex');
            openCameraButton.classList.remove('hidden');
            uploadImageButton.classList.remove('hidden'); // Show upload button again
            cameraStatus.textContent = "";

            // Analyze the captured image for location
            const identifiedLocation = await analyzeImageForLocation(imageDataUrl);

            if (identifiedLocation) {
                postcodeValue.value = identifiedLocation; // Set the input field with identified location
                postcodeForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true })); // Trigger story generation
            } else {
                cameraStatus.textContent = "No clear landmark, historic object, or historic human identified from image. Please try again or enter manually.";
            }
        });

        closeCameraButton.addEventListener('click', () => {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null;
                currentStream = null;
            }
            cameraFeedContainer.classList.add('hidden');
            cameraFeedContainer.classList.remove('flex');
            openCameraButton.classList.remove('hidden');
            uploadImageButton.classList.remove('hidden'); // Show upload button again
            cameraStatus.textContent = "";
        });

        // --- Image Upload Feature Event Listeners ---
        uploadImageButton.addEventListener('click', () => {
            errorMessage.classList.add('hidden');
            cameraStatus.textContent = ""; // Clear camera status
            imageUploadInput.click(); // Trigger the hidden file input click
        });

        imageUploadInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                displayError("No file selected.");
                return;
            }

            if (!file.type.startsWith('image/')) {
                displayError("Please upload an image file.");
                return;
            }

            cameraStatus.textContent = "Reading image file...";
            cameraStatus.classList.remove('hidden');
            loadingIndicator.classList.remove('hidden');

            const reader = new FileReader();
            reader.onload = async (e) => {
                const imageDataUrl = e.target.result; // Base64 encoded image
                
                // Hide camera controls if they were visible
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                    cameraFeed.srcObject = null;
                    currentStream = null;
                }
                cameraFeedContainer.classList.add('hidden');
                cameraFeedContainer.classList.remove('flex');
                openCameraButton.classList.remove('hidden');
                uploadImageButton.classList.remove('hidden'); // Ensure it's visible again

                const identifiedTerm = await analyzeImageForLocation(imageDataUrl);
                if (identifiedTerm) {
                    postcodeValue.value = identifiedTerm;
                    postcodeForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
                } else {
                    cameraStatus.textContent = "Could not identify a clear term from the uploaded image. Please try again or enter manually.";
                }
                loadingIndicator.classList.add('hidden');
            };
            reader.onerror = (e) => {
                console.error("FileReader error:", e);
                displayError("Failed to read image file.");
                loadingIndicator.classList.add('hidden');
                cameraStatus.textContent = "";
            };
            reader.readAsDataURL(file); // Read the file as a Base64 Data URL
        });


        // Initial update of search history panel on page load
        document.addEventListener('DOMContentLoaded', () => {
            updateSearchHistoryPanel();
            document.getElementById('currentYear').textContent = new Date().getFullYear();
        });

    </script>

</body>
</html>
